/**
 * EvolutionManager handles the system's evolutionary stages
 * It tracks the current stage and manages transitions between stages
 * 
 * @module EvolutionManager
 */

/**
 * Evolution stage definition
 */
interface EvolutionStage {
  /**
   * Unique identifier for the stage
   */
  id: string;
  
  /**
   * Name of the stage (e.g., MVP, STABLE, ADVANCED)
   */
  name: string;
  
  /**
   * Description of the stage and its capabilities
   */
  description: string;
  
  /**
   * Version number of the stage
   */
  version: string;
  
  /**
   * Features available in this stage
   */
  features: string[];
  
  /**
   * Constraints that apply in this stage
   */
  constraints: string[];
  
  /**
   * Migration path to the next stage
   */
  migrationPath?: string;
  
  /**
   * Requirements for entering this stage
   */
  entryRequirements: {
    /**
     * Minimum test coverage required
     */
    testCoverage: number;
    
    /**
     * Required performance metrics
     */
    performance: {
      constraintGenerationTime: number; // in ms
      tccGenerationTime: number; // in ms
    };
    
    /**
     * Required stability metrics
     */
    stability: {
      errorRate: number;
      uptime: number;
    };
  };
}

/**
 * Current evolution state
 */
interface EvolutionState {
  /**
   * Current stage of evolution
   */
  currentStage: string;
  
  /**
   * Timestamp when the current stage was entered
   */
  enteredAt: string;
  
  /**
   * Version of the current stage
   */
  version: string;
  
  /**
   * Migration history
   */
  migrationHistory: Array<{
    fromStage: string;
    toStage: string;
    timestamp: string;
    success: boolean;
    notes?: string;
  }>;
  
  /**
   * Self-constraints generated by the system
   */
  selfConstraints: string[];
}

/**
 * EvolutionManager class that manages the system's evolution
 */
export class EvolutionManager {
  private state: EvolutionState;
  private stages: Record<string, EvolutionStage> = {};
  
  constructor() {
    this.state = this.loadState();
    
    // Ensure current stage exists
    if (!this.stages[this.state.currentStage]) {
      console.warn(`Current stage ${this.state.currentStage} not found, resetting to MVP`);
      this.state.currentStage = 'MVP';
      this.state.enteredAt = new Date().toISOString();
      this.state.version = this.getDefaultStages()['MVP'].version;
      this.saveState();
    }
  }
  
  /**
   * Gets the default stages in case file loading fails
   * @returns Record of EvolutionStage objects
   */
  private getDefaultStages(): Record<string, EvolutionStage> {
    return {
      'MVP': {
        id: 'MVP',
        name: 'Minimum Viable Product',
        description: 'Initial version with core specification and constraint generation',
        version: '1.0',
        features: [
          'SpecificationManager',
          'ConstraintGenerator',
          'TCC generation'
        ],
        constraints: [
          'BSL validation',
          'Template-based constraints'
        ],
        entryRequirements: {
          testCoverage: 0,
          performance: {
            constraintGenerationTime: 1000,
            tccGenerationTime: 500
          },
          stability: {
            errorRate: 0.1,
            uptime: 0.9
          }
        }
      },
      'STABLE': {
        id: 'STABLE',
        name: 'Stable Release',
        description: 'Production-ready version with enhanced reliability and performance',
        version: '2.0',
        features: [
          'Advanced constraint validation',
          'Real-time feedback',
          'Improved error handling'
        ],
        constraints: [
          '90%+ test coverage',
          'Performance monitoring',
          'Graceful degradation'
        ],
        migrationPath: 'ADVANCED',
        entryRequirements: {
          testCoverage: 90,
          performance: {
            constraintGenerationTime: 100,
            tccGenerationTime: 50
          },
          stability: {
            errorRate: 0.01,
            uptime: 0.99
          }
        }
      },
      'ADVANCED': {
        id: 'ADVANCED',
        name: 'Advanced Capabilities',
        description: 'Version with AI-driven optimization and self-evolution',
        version: '3.0',
        features: [
          'AI-powered constraint generation',
          'Self-referential governance',
          'Automated evolution'
        ],
        constraints: [
          'AI model validation',
          'Self-constraint verification',
          'Automated testing'
        ],
        entryRequirements: {
          testCoverage: 95,
          performance: {
            constraintGenerationTime: 50,
            tccGenerationTime: 25
          },
          stability: {
            errorRate: 0.001,
            uptime: 0.999
          }
        }
      }
    };
  }
  
  /**
   * Asynchronously loads evolution stages and updates the instance
   */
  private async loadStagesAsync(): Promise<void> {
    try {
      this.stages = await this.loadStages();
    } catch (error) {
      console.error('Failed to load stages:', error);
      // Fallback to default stages
      this.stages = {
        'MVP': {
          id: 'MVP',
          name: 'Minimum Viable Product',
          description: 'Initial version with core specification and constraint generation',
          version: '1.0',
          features: [
            'SpecificationManager',
            'ConstraintGenerator',
            'TCC generation'
          ],
          constraints: [
            'BSL validation',
            'Template-based constraints'
          ],
          entryRequirements: {
            testCoverage: 0,
            performance: {
              constraintGenerationTime: 1000,
              tccGenerationTime: 500
            },
            stability: {
              errorRate: 0.1,
              uptime: 0.9
            }
          }
        },
        'STABLE': {
          id: 'STABLE',
          name: 'Stable Release',
          description: 'Production-ready version with enhanced reliability and performance',
          version: '2.0',
          features: [
            'Advanced constraint validation',
            'Real-time feedback',
            'Improved error handling'
          ],
          constraints: [
            '90%+ test coverage',
            'Performance monitoring',
            'Graceful degradation'
          ],
          migrationPath: 'ADVANCED',
          entryRequirements: {
            testCoverage: 90,
            performance: {
              constraintGenerationTime: 100,
              tccGenerationTime: 50
            },
            stability: {
              errorRate: 0.01,
              uptime: 0.99
            }
          }
        },
        'ADVANCED': {
          id: 'ADVANCED',
          name: 'Advanced Capabilities',
          description: 'Version with AI-driven optimization and self-evolution',
          version: '3.0',
          features: [
            'AI-powered constraint generation',
            'Self-referential governance',
            'Automated evolution'
          ],
          constraints: [
            'AI model validation',
            'Self-constraint verification',
            'Automated testing'
          ],
          entryRequirements: {
            testCoverage: 95,
            performance: {
              constraintGenerationTime: 50,
              tccGenerationTime: 25
            },
            stability: {
              errorRate: 0.001,
              uptime: 0.999
            }
          }
        }
      };
    }
  }
  
  /**
   * Loads evolution stages from configuration
   * @returns Record of EvolutionStage objects
   */
  private async loadStages(): Promise<Record<string, EvolutionStage>> {
    try {
      const fs = await import('fs').then(mod => mod.promises);
      const path = await import('path');
      
      // Get the directory path
      const currentDir = typeof __dirname !== 'undefined' ? 
        __dirname : 
        process.cwd();
      
      const filePath = path.join(currentDir, 'stages.json');
      const data = await fs.readFile(filePath, 'utf8');
      const stagesData = JSON.parse(data);
      
      // Convert array to record
      const stages: Record<string, EvolutionStage> = {};
      for (const stage of stagesData.stages) {
        stages[stage.id] = stage;
      }
      
      return stages;
    } catch (error) {
      console.warn('Could not load stages from file, using default stages');
      // Return default stages if file cannot be loaded
      return {
        'MVP': {
          id: 'MVP',
          name: 'Minimum Viable Product',
          description: 'Initial version with core specification and constraint generation',
          version: '1.0',
          features: [
            'SpecificationManager',
            'ConstraintGenerator',
            'TCC generation'
          ],
          constraints: [
            'BSL validation',
            'Template-based constraints'
          ],
          entryRequirements: {
            testCoverage: 0,
            performance: {
              constraintGenerationTime: 1000,
              tccGenerationTime: 500
            },
            stability: {
              errorRate: 0.1,
              uptime: 0.9
            }
          }
        },
        'STABLE': {
          id: 'STABLE',
          name: 'Stable Release',
          description: 'Production-ready version with enhanced reliability and performance',
          version: '2.0',
          features: [
            'Advanced constraint validation',
            'Real-time feedback',
            'Improved error handling'
          ],
          constraints: [
            '90%+ test coverage',
            'Performance monitoring',
            'Graceful degradation'
          ],
          migrationPath: 'ADVANCED',
          entryRequirements: {
            testCoverage: 90,
            performance: {
              constraintGenerationTime: 100,
              tccGenerationTime: 50
            },
            stability: {
              errorRate: 0.01,
              uptime: 0.99
            }
          }
        },
        'ADVANCED': {
          id: 'ADVANCED',
          name: 'Advanced Capabilities',
          description: 'Version with AI-driven optimization and self-evolution',
          version: '3.0',
          features: [
            'AI-powered constraint generation',
            'Self-referential governance',
            'Automated evolution'
          ],
          constraints: [
            'AI model validation',
            'Self-constraint verification',
            'Automated testing'
          ],
          entryRequirements: {
            testCoverage: 95,
            performance: {
              constraintGenerationTime: 50,
              tccGenerationTime: 25
            },
            stability: {
              errorRate: 0.001,
              uptime: 0.999
            }
          }
        }
      };
    }
  }
  
  /**
   * Loads current evolution state from storage
   * @returns EvolutionState object
   */
  private loadState(): EvolutionState {
    // In a real implementation, this would load from a file or database
    // For now, we'll use a default state
    return {
      currentStage: 'MVP',
      enteredAt: new Date().toISOString(),
      version: '1.0',
      migrationHistory: [],
      selfConstraints: []
    };
  }
  
  /**
   * Saves current evolution state to storage
   */
  private saveState(): void {
    // In a real implementation, this would save to a file or database
    // For now, we'll just log the state
    console.log('Evolution state saved:', JSON.stringify(this.state, null, 2));
  }
  
  /**
   * Gets the current evolution stage
   * @returns EvolutionStage object
   */
  getCurrentStage(): EvolutionStage {
    if (!this.stages[this.state.currentStage]) {
      return this.getDefaultStages()[this.state.currentStage];
    }
    return this.stages[this.state.currentStage];
  }
  
  /**
   * Gets the current evolution state
   * @returns EvolutionState object
   */
  getState(): EvolutionState {
    return { ...this.state };
  }
  
  /**
   * Generates self-constraints based on current stage
   * @returns Array of constraint IDs
   */
  generateSelfConstraints(): string[] {
    const stage = this.getCurrentStage();
    const selfConstraints: string[] = [];
    
    // Add stage-specific self-constraints
    switch (this.state.currentStage) {
      case 'MVP':
        selfConstraints.push('SELF-CONSTRAINT-MVP-001');
        break;
      case 'STABLE':
        selfConstraints.push('SELF-CONSTRAINT-STABLE-001');
        break;
      case 'ADVANCED':
        selfConstraints.push('SELF-CONSTRAINT-ADVANCED-001');
        break;
    }
    
    // Add any additional self-constraints based on system state
    if (this.state.selfConstraints.length > 0) {
      selfConstraints.push(...this.state.selfConstraints);
    }
    
    return selfConstraints;
  }
  
  /**
   * Attempts to migrate to the next evolutionary stage
   * @returns boolean indicating if migration was successful
   */
  async migrateToNextStage(): Promise<boolean> {
    const currentStage = this.getCurrentStage();
    
    // Check if there's a migration path
    if (!currentStage.migrationPath) {
      console.log(`No migration path from current stage ${this.state.currentStage}`);
      return false;
    }
    
    const nextStageId = currentStage.migrationPath;
    const nextStage = this.stages[nextStageId];
    
    if (!nextStage) {
      console.error(`Next stage ${nextStageId} not found`);
      return false;
    }
    
    // Check if entry requirements are met
    if (!(await this.checkEntryRequirements(nextStage))) {
      console.log(`Entry requirements not met for stage ${nextStageId}`);
      return false;
    }
    
    // Perform migration
    try {
      // Update state
      const previousStage = this.state.currentStage;
      this.state.currentStage = nextStageId;
      this.state.enteredAt = new Date().toISOString();
      this.state.version = nextStage.version;
      
      // Add to migration history
      this.state.migrationHistory.push({
        fromStage: previousStage,
        toStage: nextStageId,
        timestamp: new Date().toISOString(),
        success: true
      });
      
      // Save state
      this.saveState();
      
      console.log(`Successfully migrated from ${previousStage} to ${nextStageId}`);
      return true;
    } catch (error) {
      // Migration failed, log error and update history
      console.error('Migration failed:', error);
      
      this.state.migrationHistory.push({
        fromStage: this.state.currentStage,
        toStage: nextStageId,
        timestamp: new Date().toISOString(),
        success: false,
        notes: error instanceof Error ? error.message : 'Unknown error'
      });
      
      this.saveState();
      return false;
    }
  }
  
  /**
   * Checks if entry requirements for a stage are met
   * @param stage - The EvolutionStage to check requirements for
   * @returns boolean indicating if requirements are met
   */
  private async checkEntryRequirements(stage: EvolutionStage): Promise<boolean> {
    // In a real implementation, this would check actual system metrics
    // For now, we'll use placeholder values
    const metrics = {
      testCoverage: 95, // Placeholder value
      performance: {
        constraintGenerationTime: 80, // in ms
        tccGenerationTime: 40 // in ms
      },
      stability: {
        errorRate: 0.005,
        uptime: 0.995
      }
    };
    
    // Check test coverage
    if (metrics.testCoverage < stage.entryRequirements.testCoverage) {
      return false;
    }
    
    // Check performance
    if (metrics.performance.constraintGenerationTime > stage.entryRequirements.performance.constraintGenerationTime ||
        metrics.performance.tccGenerationTime > stage.entryRequirements.performance.tccGenerationTime) {
      return false;
    }
    
    // Check stability
    if (metrics.stability.errorRate > stage.entryRequirements.stability.errorRate ||
        metrics.stability.uptime < stage.entryRequirements.stability.uptime) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Adds a self-constraint to the system
   * @param constraintId - The ID of the constraint to add
   */
  addSelfConstraint(constraintId: string): void {
    if (!this.state.selfConstraints.includes(constraintId)) {
      this.state.selfConstraints.push(constraintId);
      this.saveState();
    }
  }
  
  /**
   * Removes a self-constraint from the system
   * @param constraintId - The ID of the constraint to remove
   */
  removeSelfConstraint(constraintId: string): void {
    this.state.selfConstraints = this.state.selfConstraints.filter(id => id !== constraintId);
    this.saveState();
  }
}
